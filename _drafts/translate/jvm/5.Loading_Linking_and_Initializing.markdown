---
layout: post
title: "Loading, Linking and Initializing"
description: "Chapter 5 Loading,Linking, and Initializing"
category: index
tags: [jvm, spec, translate]
published: true
---

{% highlight ruby %}
THE Java Virtual Machine dynamically loads, links and initializes classes and
interfaces. Loading is the process of finding the binary representation of a class
or interface type with a particular name and creating a class or interface from
that binary representation. Linking is the process of taking a class or interface and
combining it into the run-time state of the Java Virtual Machine so that it can be
executed. Initialization of a class or interface consists of executing the class or
interface initialization method <clinit> (§2.9).
{% endhighlight %}

자바 가상 머신(JVM) 은 클래스와 인터페이스를 동적으로 로드하고 링크한 후 초기화 한다.
로딩은 특정 이름으로 클래스 또는 인터페이스 타입의 바이너리 표현을 찾고 해당 바이너리 표현에서 클래스 또는 인터페이스를 생성하는 과정이다.
링크는 클래스 또는 인터페이스를 획득하고 실행할 수 있도록 자바 가상 머신 실행시의 상태를 결합하는 과정이다.
클래스 또는 인터페이스의 초기화는 클래스 또는 인터페이스의 초기화 메소드 <clinit> 를 실행하는 것으로 구성되어 있다.(§2.9).

{% highlight ruby %}
In this chapter, §5.1 describes how the Java Virtual Machine derives symbolic
references from the binary representation of a class or interface. §5.2 explains
how the processes of loading, linking, and initialization are first initiated by the
Java Virtual Machine. §5.3 specifies how binary representations of classes and
interfaces are loaded by class loaders and how classes and interfaces are created.
Linking is described in §5.4. §5.5 details how classes and interfaces are initialized.
§5.6 introduces the notion of binding native methods. Finally, §5.7 describes when
a Java Virtual Machine exits.
{% endhighlight %}

이번장 §5.1 에서는 자바 가상 머신이 클래스 또는 인터페이스의 바이너리 표현에서 어떻게 상징적인 참조를 얻는지 설명한다.
§5.2 는 로드, 링크, 초기화의 과정이 자바 가상 머신에 의해 처음 시작하는 방법을 설명한다.
§5.3 은 클래스와 인터페이스의 바이너리 표현이 어떻게 클래스 로더에 의해 로드되고 클래스와 인터페이스를 만드는지 설명한다.
링크는 §5.4 에서 설명한다. §5.5 은 클래스와 인터페이스가 어떻게 초기화되는지 자세하게 설명한다.
§5.6 에서는 네이티브 메소드 바인딩의 개념을 소개합니다. 마지막으로 §5.7 은 자바 가상 머신이 종료되는 때를 설명한다.

{% highlight ruby %}
5.1 The Run-Time Constant Pool
The Java Virtual Machine maintains a per-type constant pool (§2.5.5), a run-time
data structure that serves many of the purposes of the symbol table of a conventional
programming language implementation.
The constant_pool table (§4.4) in the binary representation of a class or interface
is used to construct the run-time constant pool upon class or interface creation
(§5.3). All references in the run-time constant pool are initially symbolic. The
symbolic references in the run-time constant pool are derived from structures in
the binary representation of the class or interface as follows:
• A symbolic reference to a class or interface is derived from a
CONSTANT_Class_info structure (§4.4.1) in the binary representation of a class
or interface. Such a reference gives the name of the class or interface in the form
returned by the Class.getName method, that is:
– For a nonarray class or an interface, the name is the binary name (§4.2.1) of
the class or interface.
– For an array class of n dimensions, the name begins with n occurrences of the
ASCII "[" character followed by a representation of the element type:
› If the element type is a primitive type, it is represented by the corresponding
field descriptor (§4.3.2).
› Otherwise, if the element type is a reference type, it is represented by the
ASCII "L" character followed by the binary name (§4.2.1) of the element
type followed by the ASCII ";" character.
Whenever this chapter refers to the name of a class or interface, it should be
understood to be in the form returned by the Class.getName method.
• A symbolic reference to a field of a class or an interface is derived from a
CONSTANT_Fieldref_info structure (§4.4.2) in the binary representation of a
class or interface. Such a reference gives the name and descriptor of the field,
as well as a symbolic reference to the class or interface in which the field is to
be found.
• A symbolic reference to a method of a class is derived from a
CONSTANT_Methodref_info structure (§4.4.2) in the binary representation of a
class or interface. Such a reference gives the name and descriptor of the method,
as well as a symbolic reference to the class in which the method is to be found.
• A symbolic reference to a method of an interface is derived from
a CONSTANT_InterfaceMethodref_info structure (§4.4.2) in the binary
representation of a class or interface. Such a reference gives the name and
descriptor of the interface method, as well as a symbolic reference to the interface
in which the method is to be found.
• A
a method handle is derived from a
CONSTANT_MethodHandle_info structure (§4.4.8) in the binary representation of
a class or interface. Such a reference gives a symbolic reference to a field of a
class or interface, or a method of a class, or a method of an interface, depending
on the kind of the method handle.
{% endhighlight %}

5.1 런타임 상수 풀
자바 가상 머신은 해당 타입의 상수 풀(§2.5.5)을 통해 전통적인 프로그래밍 언어로 구현된 심볼 테이블의 목적을 많이 제공하는 런타임 데이터 구조를 유지한다.
클래스 또는 인터페이스의 바이너리 표현에 있는 상수 풀 테이블(§4.4)은 클래스 또는 인터페이스 생성시(§5.3) 런타임 상수 풀을 구성하는데 사용된다.
런타임 상수풀에 있는 모든 참조는 처음 상징적이다. 다음과 같이 런타임 상수 풀의 상직적 참조는 클래스 또는 인터페이스의 바이너리 표현 구조에서 파생된다 :

• 클래스 또는 인터페이스의 상징적 참조는 클래스나 인터페이스의 바이너리 표현의 상수 클래스 정보 구조 (§4.4.1)에서 파생된다.
  이러한 참조는 Class.getName 메소드에 의해 반환되는 형태의 클래스 또는 인터페이스의 이름을 제공한다. 즉 :
  – 배열이 아닌 클래스 또는 인터페이스의 경우, 이름은 클래스 또는 인터페이스의 바이너리 명 (§4.2.1) 이다.
  – N 차원의 배열 클래스 이름은 ASCII "["의 문자로 시작하고 요소 유형 N 을 다음에 표시 :
    › 요소 유형이 기본 타입인 경우에는 해당 필드 기술자에 의해 표현된다(§4.3.2).
    › 요소 유형이 참조 타입인 경우에는 ASCII "L" 문자 다음 요소 유형의 바이너리 이름 (§4.2.1) 뒤에 ASCII ";" 문자로 표현된다.



    Whenever this chapter refers to the name of a class or interface, it should be
    understood to be in the form returned by the Class.getName method.
    • A symbolic reference to a field of a class or an interface is derived from a
    CONSTANT_Fieldref_info structure (§4.4.2) in the binary representation of a
    class or interface. Such a reference gives the name and descriptor of the field,
    as well as a symbolic reference to the class or interface in which the field is to
    be found.
